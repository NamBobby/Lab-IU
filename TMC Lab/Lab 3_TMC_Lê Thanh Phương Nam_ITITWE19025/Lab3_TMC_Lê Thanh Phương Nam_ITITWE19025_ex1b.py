# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19BTHA6RHgyEfLESnfTFFcF6lT1eFM2Xw
"""

import numpy as np
import scipy
from scipy.linalg import lu, lu_factor, lu_solve

print('LeThanhPhuongNam_ITITWE19025\n\n\n')
print('a) Using numpy')
A=np.array([[1,4,9,16],[4,9,16,25],[9,16,25,36],[16,25,36,49]])
B=np.array([30,54,86,126])
B.shape=(4,1)
x_normal= np.linalg.solve(A,B)
print(A)
print(B)
print('Solution:')
print(x_normal)
#AA=A**(-1)
print('Inverse martrix')
print(np.linalg.inv(A))

print('LeThanhPhuongNam_ITITWE19025\n\n\n')
print('b) Using LU decompision')
P, L, U = scipy.linalg.lu(A)
print(A) 
print(P)
print(L)
print(U)
print(L @ U)
np.allclose(L @ U,A)
np.allclose(L@U, B)

from time import time

start = time()

LU, p=lu_factor(A)
lu_solve((LU,p),B)
print('Time using LU= ',time()-start)
print('Solution:')
print(lu_solve)
np.linalg.solve(A,B)

print('LeThanhPhuongNam_ITITWE19025\n\n\n')
print('c) Using SVD method')
from numpy.linalg import svd, cholesky
from numpy.linalg import matrix_rank as rank
from scipy.linalg import diagsvd
def sol_svd(A,B):
  u,s,vt = svd(A)
  # A*x=B
  # x=inv(A).B A=u.s.vt
  # x=int(vt).inv(s).inv(u).B
  r=rank(A)
  s[:r]=1/s[:r]
  m,n = A.shape
  s_inv = diagsvd(s,m,n).T
  x= vt.T.dot(s_inv).dot(u.T).dot(B)
  return x

start2 = time()
x_svd = sol_svd(A,B)
print('Time using SVD = ', time()-start2)
print('Solution:')
print(x_svd)

print('LeThanhPhuongNam_ITITWE19025\n\n\n')
print('d) Using Gauss Elimination')
length = len(B)
z = np.zeros(length, float)

def GaussMethod(a,b,n,x):
#Forward elimination
    for k in range(0, n-1):
        for i in range(k+1, n):
            ratio = a[i, k]/a[k, k]
            for j in range (k, n):
                a[i, j] = a[i, j] - ratio*a[k, j]
            b[i] = b[i]- ratio*b[k]
#Backward substitution
    x[n-1] = b[n-1]/a[n-1, n-1]
    for i in range(n-2, -1, -1):
        sum = b[i]
        for j in range(i+1, n):
            sum = sum - a[i, j]*x[j]
        x[i] = sum/a[i,i]
    return x

start3 = time()
sol_Gauss = GaussMethod(A,B,length,z)
print('Solution:\n',sol_Gauss)
print('\nTime using Guassian elimination: ',time()-start3)

print('LeThanhPhuongNam_ITITWE19025\n\n\n')
print('e) Using Using Cholesky')
def choleskyDecomposition(A):

    # Get the size of the input matrix
    n = A.shape[0]

    # Create output matrices of the same size
    L = np.zeros((n, n))
    inverseL = np.zeros((n, n))

    # Loop over rows and columns
    for i in range(n):

        for j in range(n):

            if (i < j):

                L.itemset((i, j), 0.0)

            elif (i == j):

                sum = 0.0

                for k in range(i):

                    sum += L[i, k] * L[i, k]

                if (A[i, j] - sum > 0.0):

                    L.itemset((i, j), np.sqrt(A[i, j] - sum))

                else:

                    print('The Cholesky decomposition failed at Operation 1')
                    return [L, inverseL]

            elif (i > j):

                sum = 0.0
                for k in range(j):

                    sum += L[i, k] * L[j, k]

                if (L[j, j] != 0.0):

                    L.itemset((i, j), ((A[i, j] - sum) / L[j, j]))


                else:

                    print('The Cholesky decomposition failed at Operation 2')
                    return [L, inverseL]

    # Compute the inverse Cholesky matrix
    for i in range(n):

        for j in range(n-1, -1, -1):

            if (i < j):

                inverseL.itemset((i, j), 0.0)

            elif (i == j):

                if (L[i, j] != 0.0):

                    inverseL.itemset((i, j), 1.0 / L[i, j])

                else:

                    print('The Cholesky inversion failed at Operation 3')
                    return [L, inverseL]

            elif (i > j):

                sum = 0.0
                for k in range(j, i, 1):

                    sum += L[i, k] * inverseL[k, j]

                if (L[i, i] != 0.0):

                    inverseL.itemset((i, j), (-sum/L[i, i]))

                else:

                    print('The Cholesky inversion failed at Operation 4')
                    return [L, inverseL]

    return [L, inverseL]

# Test of the Cholesky algorithm
start4 = time()
[L, inverseL] = choleskyDecomposition(A)
print('The Cholesky decomposition is:', L)
print('The inverse is:', inverseL)
print('Time using Cholesky decomposition = ', time()-start4)

